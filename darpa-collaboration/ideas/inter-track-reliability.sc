
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Pseudo-code for this file
;;;
;;; Take a given video
;;; + Get get all the pairs of teams (unique-pairs *teams*)
;;; + For each pair, get all team-video-tracks
;;; ++ Calculate all possible score pairings (person->person and other->other)
;;; ++ Match tracks based on best possible score (all pairwise combinations)
;;; ++ We now have a single score for a (video-team-team) tuple. Note scores
;;;    are weighted by the number of frames used to generate them.
;;; ++ Cache the score to disk, in the folder *box-coder-data-dir*
;;; + We can now average all the scores across a given team-pair (weighted by
;;;   number of frames used.
;;;
;;; There are two implemented scoring metrics:
;;; + *intersection-union-metric*, box intersection-area / union-area
;;; + *centre-distance-metric*, the distance between the box centres
;;;
;;; TO EXECUTE THIS CODE - (or see an example of how to)
;;; See the README file bash scripts in:
;;; ~/darpa-collaboration/documentation/convert-other-teams-tracks
;;; 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Definitions
;;; The teams (different trake types)
(define *teams* '("PDU" "SBU" "SRI" "UCB" "USC"))
(define (all-videos) (videos-by-corpus "C-D1/recognition"))
(define *box-coder-data-dir* "/aux/amichaux/tmp/data")
(define *recalculate-results* #f)
(define *max-permutations-to-try* 6) ; Never try more matchings then this

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Boxes
;;; Box structure: left, top, right, bottom (ie: x1, y1, x2, y2)
(define-structure box-st l t r b)

;;; Converts a voc4-detection structure to a box-st structure
(define (voc4-track->box-st track)
 (make-box-st (voc4-detection-x1 track)
		  (voc4-detection-y1 track)
		  (voc4-detection-x2 track)
		  (voc4-detection-y2 track)))

;;; Each metric has a name (so that the results can be cached) and a function
;;; 'fun' takes two box-st structures and returns a score, or #f if the boxes are
;;; unscorable for some reason. 'best-fun' a list of scores (each generated by fun),
;;; and returns the best one (usually the highest or lowest)
(define-structure metric name fun best-fun)

(define (choose-best-score metric scores)
 (let loop ((best (first scores))
		(fun (metric-best-fun metric))
		(scores (rest scores)))
  (if (null? scores)
	best
	(loop (if (fun (list (second best) (second (first scores))))
		    best
		    (first scores))
		fun
		(rest scores)))))

(define *intersection-union-metric*
 (make-metric "intersection-union"
		  (lambda (box-1 box-2) (box-st-overlap-score box-1 box-2))
		  maximum))

(define *sqrt-intersection-union-metric*
 (make-metric "sqrt-intersection-union"
		  (lambda (box-1 box-2)
		   (let ((raw-score (box-st-overlap-score box-1 box-2)))
		    (if (number? raw-score)
			  (sqrt raw-score)
			  #f)))
		  maximum))

(define *centre-distance-metric*
 (make-metric "centre-distance"
		  (lambda (box-1 box-2) (box-st-centre-offset-score box-1 box-2))
		  minimum))

(define *diagonal-overlap*
 (make-metric "diagonal-overlap"
		  (lambda (box-1 box-2) (box-st-diagnoal-overlap-score box-1 box-2))
		  maximum))

;;; True, iff, all co-ordinates of the box are -1
(define (null-box-st? box)
 (and (= -1 (box-st-l box)) (= -1 (box-st-t box))
      (= -1 (box-st-r box)) (= -1 (box-st-b box))))

;;; (box-st-area (make-box-st 10 10 50 50)) => 1600
(define (box-st-area box)
 (* (- (box-st-r box) (box-st-l box)) (- (box-st-b box) (box-st-t box))))

;;; The centre of a box (as a vector)
(define (box-st-centre box)
 (make-vector 2
		  (* 0.5 (+ (box-st-l box) (box-st-r box)))
		  (* 0.5 (+ (box-st-t box) (box-st-b box)))))

;;; (box-st-union (make-box-st 10 10 20 20) (make-box-st 4 14 15 33)) => #(BOX-ST 4 10 20 33)
(define (box-st-union box-1 box-2)
 (make-box-st (min (box-st-l box-1) (box-st-l box-2))
		  (min (box-st-t box-1) (box-st-t box-2))
		  (max (box-st-r box-1) (box-st-r box-2))
		  (max (box-st-b box-1) (box-st-b box-2))))

;;; (box-st-intersection (make-box-st 10 88 20 99) (make-box-st 24 14 15 33))
;;;      => #(BOX-ST 24 88 24 88)
(define (box-st-intersection box-1 box-2)
 (let ((l (max (box-st-l box-1) (box-st-l box-2)))
       (t (max (box-st-t box-1) (box-st-t box-2)))
       (r (min (box-st-r box-1) (box-st-r box-2)))
       (b (min (box-st-b box-1) (box-st-b box-2))))
  (make-box-st l t (if (> l r) l r) (if (> t b) t b))))

;;; Intersection-area / Union-area, or #f if either box-1 or box-2 are null-box-st?
(define (box-st-overlap-score box-1 box-2)
 (cond
  ((null-box-st? box-1) #f)
  ((null-box-st? box-2) #f)
  (else
   (let* ((intersection-area (box-st-area (box-st-intersection box-1 box-2)))
	    (union-area (- (+ (box-st-area box-1) (box-st-area box-2)) intersection-area)))
    (if (= 0 union-area)
	  0 ; both boxes had no area -- so assume they don't overlap. Corner case.
	  (/ intersection-area union-area))))))

;;; Returns distance between the centres of two boxes, or #f if any box is invalid 
(define (box-st-centre-offset-score box-1 box-2)
 (cond
  ((null-box-st? box-1) #f)
  ((null-box-st? box-2) #f)
  (else (distance (box-st-centre box-1) (box-st-centre box-2)))))

(define (box-st-diagnoal-overlap-score box-1 box-2)
 (cond
  ((null-box-st? box-1) #f)
  ((null-box-st? box-2) #f)
  (else
   (let ((box-intersect (box-st-intersection box-1 box-2)))
    (if (or (= (box-st-l box-intersect) (box-st-r box-intersect))
		(= (box-st-t box-intersect) (box-st-b box-intersect)))
	  0 ; No intersection means no score
	  (average
	   (map (lambda (p) (/ (apply distance (line-box-intersect (first p) (second p) box-intersect))
				     (distance (first p) (second p))))
		  (list (list `#(,(box-st-l box-1) ,(box-st-t box-1)) `#(,(box-st-r box-1) ,(box-st-b box-1)))
			  (list `#(,(box-st-l box-1) ,(box-st-b box-1)) `#(,(box-st-r box-1) ,(box-st-t box-1)))
			  (list `#(,(box-st-l box-2) ,(box-st-t box-2)) `#(,(box-st-r box-2) ,(box-st-b box-2)))
			  (list `#(,(box-st-l box-2) ,(box-st-b box-2)) `#(,(box-st-r box-2) ,(box-st-t box-2)))))))))))

;;; Returns a pair of points for the intersection of the line with the passed box
;;; (line-box-intersect '#(-10 20) '#(10 10) (make-box-st 0 0 20 20)) => (#(0 15) #(10 10))
(define (line-box-intersect p1 p2 box)
 (define (calc-y equation x) (+ (* (first equation) x) (second equation)))
 (define (calc-x equation y) (/ (- y (second equation)) (first equation)))
 (define (intersect-of a b u v)
  (define (clip-above x max-x) (if (> x max-x) max-x x))
  (define (clip-below x min-x) (if (< x min-x) min-x x))
  (cond
   ((> a b) (intersect-of b a u v))
   ((> u v) (intersect-of a b v u))
   (else
    `#(,(clip-above (max a u) v) ,(clip-below (min b v) u)))))
 (define (line-gradient p1 p2)
  (if (= (x p1) (x p2))
      infinity
      (/ (- (y p2) (y p1)) (- (x p2) (x p1)))))
 (define (line-equation p1 p2)
  (let ((m (line-gradient p1 p2)))
   (if (equal? m infinity)
       (list m (x p1))
       (list m (- (y p1) (* m (x p1)))))))
 (cond
  ((= (x p1) (x p2)) ;; vertical line
   (if (and (>= (x p1) (box-st-l box)) (<= (x p1) (box-st-r box)))
       (let ((py (intersect-of (y p1) (y p2) (box-st-t box) (box-st-b box)))) 
	  (list `#(,(x p1) ,(x py)) `#(,(x p1) ,(y py))))
       (list p1 p1))) ; line outside of box
  ((= (y p1) (y p2)) ;; horizontal line
   (if (and (>= (y p1) (box-st-b box)) (<= (y p1) (box-st-t box)))
       (let ((px (intersect-of (x p1) (x p2) (box-st-l box) (box-st-r box)))) 
	  (list `#(,(x px) ,(y p1)) `#(,(y px) ,(y p1))))
       (list p1 p1))) ; line outside of box
  ((> (x p1) (x p2)) ; so that p1 is always to the left of p2
   (line-box-intersect p2 p1 box))
  (else ; oblique line, with (x p1) < (x p2)
   (let* ((equation (line-equation p1 p2))
	    (pt `#(,(calc-x equation (box-st-t box)) ,(box-st-t box)))
	    (pb `#(,(calc-x equation (box-st-b box)) ,(box-st-b box)))
	    (pl `#(,(box-st-l box) ,(calc-y equation (box-st-l box))))
	    (pr `#(,(box-st-r box) ,(calc-y equation (box-st-r box))))
	    (px (intersect-of (x p1) (x p2) (box-st-l box) (box-st-r box)))
	    (px (intersect-of (x px) (y px) (x pt) (x pb)))
	    (py (intersect-of (y p1) (y p2) (box-st-t box) (box-st-b box)))
	    (py (intersect-of (x py) (y py) (y pl) (y pr))))
    (if (> (y p1) (y p2))
	  ;; line has a downward slope
	  (list `#(,(x px) ,(y py)) `#(,(y px) ,(x py)))
	  ;; line has an upward slope
	  (list `#(,(x px) ,(x py)) `#(,(y px) ,(y py))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (read-cachable-result cache-file recalculate-fun force-recalculate)
 (if (and (not force-recalculate) (file-exists? cache-file))
     (read-object-from-file cache-file)
     (let ((result (recalculate-fun)))
      (system (format #f "mkdir -p \"$(dirname \"~a\")\"" cache-file))
      (write-object-to-file result cache-file)
      result)))

;;; The file name where we cache results for the passed metric
(define (get-team-score-file video team-1 team-2 metric)
 (format #f "~a/~a-~a-~a-~a.interrater.sc"
	 *box-coder-data-dir* team-1 team-2
	 (darpa-video->string video) (metric-name metric)))

;;; Converts a team-name into their track-type
;;; (team->track-type "PDU") => "voc4"
(define (team->track-type team)
 (if (equal? team "PDU") "voc4" team))

(define (get-video-team-tracks video team)
 (video-smooth-tracked-boxes-available video (team->track-type team)))

(define (track->smooth-track-boxes video track)
 (read-smooth-tracked-boxes video (first track) (second track) (third track)))

;;; Returns a list of all permutations of subset of "lis" which are length "len"
;;; (permutate '(a b c d) 2)
;;;     ==> ((A B) (A C) (A D) (B A) (B C) (B D) (C A) (C B) (C D) (D A) (D B) (D C))
(define (permutate lis len)
 (let ((len (if (> len (length lis)) 0 len)))
  (let loop ((n 0) (res '()))
   (if (equal? n len)
       res
       (loop (+ n 1)
	     (if (equal? n 0)
		 (map list lis)
		 (remove-if-not identity
				(join (map (lambda (e)
					    (map (lambda (n)
						  (if (member e n) '() (cons e n)))
						 res))
					   lis)))))))))


;;; (unique-pairs '(a b c d)) => ((A B) (A C) (A D) (B C) (B D) (C D))
(define (unique-pairs lis)
 (let ((indicies (let ((l (enumerate (length lis))))
		  (all-values
		   (let ((v1 (a-member-of l)))
		    (list v1 (a-member-of (set-difference l (cons v1 (enumerate v1))))))))))
  (map (lambda (pair) (list (list-ref lis (first pair)) (list-ref lis (second pair))))
       indicies)))

;;; Returns a sublist of ever nth element of 'l', with the specified offset
(define (every-other-nth-o l nth offset)
 (map second
      (remove-if-not
       (lambda (e) (first e))
       (map-indexed (lambda (elem i) (list (if (equal? (remainder i nth) offset) #t #f) elem)) l))))

;;; The weighted mean of x, using weights w
(define (weighted-mean w x)
 (if (null? w)
     0
     (/ (foldl + (map * w x) 0)
	  (foldl + w 0))))

;;; Estimates the stddev for the passed list of numbers
(define (weighted-stddev-est w x)
 (if (< (length w) 2)
     0
     (let* ((sum-w (- (foldl + w 0) 1))
		(mean (weighted-mean w x))
		(xi-x (map (lambda (xi) (- xi mean)) x))
		(xx (map * w xi-x xi-x)))
      (sqrt (/ (foldl + xx 0) sum-w)))))

;;; The average of the list
(define (average l)
 (if (null? l)
     0
     (/ (foldl + l 0) (length l))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Scoring

;;; Returns the /average/ box-st-overlap-score between the two tracks,
;;; and the number of frames used to calculate the average. The number
;;; of frames is the first value in the result, and the average is the second
(define (score-tracks video track-1 track-2 metric)
 (if (not (= (length track-1) (length track-2)))
     (begin
      (format #t "~%~%~%~%################### Error in video ~a ~%~%~%~%"
	      (darpa-video->string video))
      (list 0 0))
     (let ((scores (remove-if-not number?
				  (map (metric-fun metric)
				       (map voc4-track->box-st track-1)
				       (map voc4-track->box-st track-2)))))
      (if (> (length scores) 0)
	  (list (length scores) (/ (foldl + scores 0) (length scores)))
	  (list 0 0)))))

;;; Returns the /average/ score-tracks for each pair of tracks.
;;; Both lists must be the same length
;;; The return value is a list, with the first value being the
;;; number of frames used to generate the average score, and the
;;; second being the average score.
(define (score-track-lists video track-1-list track-2-list metric)
 (if (= 0 (length track-1-list))
     (list 0 0)
     (let ((scores (map (lambda (t1 t2) (score-tracks video t1 t2 metric))
				track-1-list track-2-list)))
      (list (foldl + (map first scores) 0)
		(/ (foldl + (map second scores) 0) (length scores))))))

;;; Returns the best possible score (as define by metric, pairing each of the
;;; tracks against each of the other possible tracks. The return value is a list
;;; with two elements where the first gives the total number of frames used in
;;; the scoring, and the second gives the score.
(define (score-track-combinations video team-1-tracks team-2-tracks metric)
 (if (< (length team-2-tracks) (length team-1-tracks))
     ;; so team1-len always < team2-len
     (score-track-combinations video team-2-tracks team-1-tracks metric)
     (let ((min-len (length team-1-tracks)))
      (if (or (> min-len *max-permutations-to-try*)
		  (= min-len 0)
		  (> (length team-2-tracks) 10))
	    (list 0 0)
	    (let* ((team-2-indicies (permutate (enumerate (length team-2-tracks)) min-len))
		     (video-track->smooth-track-boxes
			(lambda (track) (track->smooth-track-boxes video track)))
		     (team-1-boxes (map video-track->smooth-track-boxes team-1-tracks))
		     (team-2-boxes (map video-track->smooth-track-boxes team-2-tracks))
		     (scores (map
				  (lambda (team-2-index-set)
				   (score-track-lists video
							    team-1-boxes
							    (map (lambda (idx) (list-ref team-2-boxes idx))
								   team-2-index-set)
							    metric))
				  team-2-indicies)))
	     (if (null? scores)
		   (list 0 0)
		   (choose-best-score metric scores)))))))

;;; Returns the score for a given video, across two teams
(define (score-video-for-teams video team-1 team-2 metric)
 (define (person-track? track) (equal? "person" (second track)))
 (let* ((team-1-tracks (get-video-team-tracks video team-1))
        (team-2-tracks (get-video-team-tracks video team-2))
	  (team-1-person-tracks (remove-if-not person-track? team-1-tracks))
	  (team-2-person-tracks (remove-if-not person-track? team-2-tracks))	
	  (team-1-other-tracks (remove-if person-track? team-1-tracks))
	  (team-2-other-tracks (remove-if person-track? team-2-tracks))
	  (person-score
	   (score-track-combinations video team-1-person-tracks team-2-person-tracks metric))
	  (other-score
	   (score-track-combinations video team-1-other-tracks team-2-other-tracks metric)))
  (if (and (equal? 0 (first person-score)) (equal? 0 (first other-score)))
      #f
      ;; This is a weighted average, by number of frames used in generating the score
      (list (+ (first person-score) (first other-score))
		(/ (+ (* (first person-score) (second person-score))
			(* (first other-score) (second other-score)))
		   (+ (first person-score) (first other-score)))))))

;;; Returns a pair with average score (over the list), and the number of scored items
;;; e.g.: (score-video-list my-list "PUR" "SRI") => (0.4432 44)
(define (score-video-list video-list team-1 team-2 metric)
 (let* ((scores
	   (map (lambda (video)
		   (format #t "~a ~a ~a => " team-1 team-2 (darpa-video->string video))
		   (let
		     ((res (read-cachable-result
				(get-team-score-file video team-1 team-2 metric)
				(lambda () (score-video-for-teams video team-1 team-2 metric))
				*recalculate-results*)))
		    (format #t "~a~%" res)
		    res))
		  video-list))
	  (short-list (remove-if (lambda (s) (equal? s #f)) scores))
	  (mean (weighted-mean (map first short-list) (map second short-list)))
	  (stddev (weighted-stddev-est (map first short-list) (map second short-list))))
  (if (null? short-list)
      (list 0 0 0 0 0) ; corner-case
      (list mean
		stddev
		(- mean (* 1.96 (/ stddev (sqrt (length short-list)))))
		(+ mean (* 1.96 (/ stddev (sqrt (length short-list)))))
		(length short-list)))))

(define (score-video-team-lists video-list team-list metric)
 (let* ((team-pairs (unique-pairs team-list))
	(scores (map (lambda (team-1 team-2)
		      (append (list team-1 team-2)
			      (score-video-list video-list team-1 team-2 metric)))
		     (map first team-pairs)
		     (map second team-pairs))))
  ;; First report on the results
  (format #t "####################### Results #####################~%")
  (format #t "Algorithm = ~a~%" (metric-name metric))
  (format #t "  TEAMS     N    MEAN   STDEV  95% Conf. Interval~%")
  (for-each
   (lambda (res)   
    (system (format #f "echo '~a ~a ~a ~a ~a ~a ~a' | awk '{ printf(\"%s-%s % 5d % 7.2f % 7.2f [% 7.2f - % 7.2f]\\n\", $1, $2, $3, $4, $5, $6, $7); }'"
		    (first res)
		    (second res)
		    (seventh res)
		    (third res)
		    (fourth res)
		    (fifth res)
		    (sixth res))))
   scores)
  (format #t "#####################################################~%")
  scores))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Main
(define (process-part-of-list every-nth offset metric)
 (score-video-team-lists (every-other-nth-o (all-videos) every-nth offset)
			 *teams*
			 metric))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Auxiliary Functions
;;; Returns information on the number of tracks for a given team
(define (report-on-video-tracks-available team video)
 (define (person-track? track) (equal? "person" (second track)))
 (let* ((tracks (get-video-team-tracks video team))
	  (person-tracks (remove-if-not person-track? tracks))
	  (other-tracks (remove-if person-track? tracks)))
  (format #t "~a ~a ~a ~a~%" team (darpa-video->string video) (length person-tracks) (length other-tracks))
  (list team (darpa-video->string video) (length person-tracks) (length other-tracks))))

;;; Reports on all videos and all teams
(define (report-all-videos-all-teams)
 (format #t "team video num-person-tracks num-other-tracks~%")
 (for-each
  (lambda (video)
   (for-each
    (lambda (team)
     (report-on-video-tracks-available team video))
    *teams*))
  (all-videos)))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Debug

;;; Returns a 'darpa' video (accessed through the ~/video-datasets
;;; symlink), or a stand-alone video (from a  fully pathed video name).
(define (load-video video-name)
 (let ((video
	  (cond
	   ((video-name->darpa-video-corpus video-name) (string->darpa-video video-name))
	   (else (make-stand-alone-video video-name)))))
  (if (video-first-frame video)
      video
      (dtrace (format #f "Failed to load video: '~a'" video-name) '()))))

;; perisikan
(define A1 "APPROACH1_A1_C3_Act6_2_URBAN1_BC_MIDD_DARK_9031057d-e83c-11df-af1b-e80688cb869a")
(define A2 "APPROACH2_A1_C2_Act6_1_PARK_MC_AFTN_DARK_b42daa38-07b6-11e0-8cee-e80688cb869a")

;; arivu
(define A3 "APPROACH10_A1_C2_Act5_6_PARK_MC_AFTN_b42d74ab-07b6-11e0-8b05-e80688cb869a")
(define A4 "APPROACH7_A1_C1_Act2_URBAN_BR_AFTN_b42e5bae-07b6-11e0-ab3c-e80688cb869a")

;; verstand
(define A5 "TOUCH2_A1_C2_Act2_6_PARK_BR_AFTN_DARK_b47aa661-07b6-11e0-b9d4-e80688cb869a")

;; upplysingaoflun
(define A6 "HAVE6_A1_C2_Act8_1_URBAN_MC_AFTN_43a1e614-1dc6-11e0-ad1b-e80688ca39a2")

(define A7 "CARRY3_A1_C1_Act1_URBAN_MC_AFTN_DARK_b3a38588-1e77-11e0-8dda-e80688ca39a2")

(define A1 "GET4_A1_C2_Act8_URBAN_BL_AFTN_43969f8e-1dc6-11e0-ad1b-e80688ca39a2")

(define V1 (load-video A1))
(define V2 (load-video A2))
(define V3 (load-video A3))
(define V4 (load-video A4))
(define V5 (load-video A5))
(define V6 (load-video A6))
(define V7 (load-video A7))

(define T1 (read-smooth-tracked-boxes V1 "USC" "person" "30903"))
(define T2 (read-smooth-tracked-boxes V1 "voc4" "person" "1"))

(define v6-s (map (lambda (team) (get-video-team-tracks V6 team)) *teams*))

(define V-list (list V1 V2 V3 V4 V5 V6))

(define b1 (make-box-st 10 5 20 30))
(define b2 (make-box-st 0 0 20 20))

(define p1 `#(0 0))
(define p2 `#(15 0))
(define p3 `#(25 0))
(define p4 `#(0 10))
(define p5 `#(15 10))
(define p6 `#(25 10))
(define p7 `#(0 40))
(define p8 `#(15 40))
(define p9 `#(25 40))

(define pc `#(10 10))



      
      

