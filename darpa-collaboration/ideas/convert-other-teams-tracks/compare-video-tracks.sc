 (define (person-track? track) (equal? "person"  (first track)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Definitions
;;; The teams (different trake types)
(define *teams* '("PDU" "SBU" "SRI" "UCB" "USC"))
(define (all-videos) (videos-by-corpus "C-D1/recognition"))
(define *box-coder-data-dir* "/aux/amichaux/tmp/data")
(define *recalculate-results* #f)
(define *max-permutations-to-try* 6) ; Never try more matchings then this

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Boxes
;;; Box structure: left, top, right, bottom (ie: x1, y1, x2, y2)
(define-structure box-st l t r b)

;;; Converts a voc4-detection structure to a box-st structure
(define (voc4-track->box-st track)
 (make-box-st (voc4-detection-x1 track)
		  (voc4-detection-y1 track)
		  (voc4-detection-x2 track)
		  (voc4-detection-y2 track)))

;;; Each metric has a name (so that the results can be cached) and a function
;;; 'fun' takes two box-st structures and returns a score, or #f if the boxes are
;;; unscorable for some reason. 'best-fun' a list of scores (each generated by fun),
;;; and returns the best one (usually the highest or lowest)
(define-structure metric name fun best-fun)
;;;(define-structure track-annotation good? name number)


(define (choose-best-score metric scores)
 (let loop ((best (first scores))
	    (fun (metric-best-fun metric))
	    (scores (rest scores)))
  (if (null? scores)
      best
      (loop (if (fun (list (second best) (second (first scores))))
		best
		(first scores))
	    fun
	    (rest scores)))))
;;; NOTE: I replaced choose best score with score highest because
;;; the above wasn't returning 100% correct answers
;;; (the answer depended on the order of the input)
;;; this is a temporary fix, since the max isnt the best
;;; for some metrics
(define (choose-highest-score scores)
     (maximump scores (lambda (score) (second score))))
     
 

(define *intersection-union-metric*
 (make-metric "intersection-union"
		  (lambda (box-1 box-2) (box-st-overlap-score box-1 box-2))
		  maximum))

(define *sqrt-intersection-union-metric*
 (make-metric "sqrt-intersection-union"
		  (lambda (box-1 box-2)
		   (let ((raw-score (box-st-overlap-score box-1 box-2)))
		    (if (number? raw-score)
			  (sqrt raw-score)
			  #f)))
		  maximum))

(define *centre-distance-metric*
 (make-metric "centre-distance"
		  (lambda (box-1 box-2) (box-st-centre-offset-score box-1 box-2))
		  minimum))

(define *diagonal-overlap*
 (make-metric "diagonal-overlap"
		  (lambda (box-1 box-2) (box-st-diagnoal-overlap-score box-1 box-2))
		  maximum))

;;; True, iff, all co-ordinates of the box are -1
(define (null-box-st? box)
 (and (= -1 (box-st-l box)) (= -1 (box-st-t box))
      (= -1 (box-st-r box)) (= -1 (box-st-b box))))

;;; (box-st-area (make-box-st 10 10 50 50)) => 1600
(define (box-st-area box)
 (* (- (box-st-r box) (box-st-l box)) (- (box-st-b box) (box-st-t box))))

;;; The centre of a box (as a vector)
(define (box-st-centre box)
 (make-vector 2
		  (* 0.5 (+ (box-st-l box) (box-st-r box)))
		  (* 0.5 (+ (box-st-t box) (box-st-b box)))))

;;; (box-st-union (make-box-st 10 10 20 20) (make-box-st 4 14 15 33)) => #(BOX-ST 4 10 20 33)
(define (box-st-union box-1 box-2)
 (make-box-st (min (box-st-l box-1) (box-st-l box-2))
		  (min (box-st-t box-1) (box-st-t box-2))
		  (max (box-st-r box-1) (box-st-r box-2))
		  (max (box-st-b box-1) (box-st-b box-2))))

;;; (box-st-intersection (make-box-st 10 88 20 99) (make-box-st 24 14 15 33))
;;;      => #(BOX-ST 24 88 24 88)
(define (box-st-intersection box-1 box-2)
 (let ((l (max (box-st-l box-1) (box-st-l box-2)))
       (t (max (box-st-t box-1) (box-st-t box-2)))
       (r (min (box-st-r box-1) (box-st-r box-2)))
       (b (min (box-st-b box-1) (box-st-b box-2))))
  (make-box-st l t (if (> l r) l r) (if (> t b) t b))))

;;; Intersection-area / Union-area, or #f if either box-1 or box-2 are null-box-st?
(define (box-st-overlap-score box-1 box-2)
 (cond
  ((null-box-st? box-1) #f)
  ((null-box-st? box-2) #f)
  (else
   (let* ((intersection-area (box-st-area (box-st-intersection box-1 box-2)))
	    (union-area (- (+ (box-st-area box-1) (box-st-area box-2)) intersection-area)))
    (if (= 0 union-area)
	  0 ; both boxes had no area -- so assume they don't overlap. Corner case.
	  (/ intersection-area union-area))))))

;;; Returns distance between the centres of two boxes, or #f if any box is invalid 
(define (box-st-centre-offset-score box-1 box-2)
 (cond
  ((null-box-st? box-1) #f)
  ((null-box-st? box-2) #f)
  (else (distance (box-st-centre box-1) (box-st-centre box-2)))))

(define (box-st-diagnoal-overlap-score box-1 box-2)
 (cond
  ((null-box-st? box-1) #f)
  ((null-box-st? box-2) #f)
  (else
   (let ((box-intersect (box-st-intersection box-1 box-2)))
    (if (or (= (box-st-l box-intersect) (box-st-r box-intersect))
		(= (box-st-t box-intersect) (box-st-b box-intersect)))
	  0 ; No intersection means no score
	  (average
	   (map (lambda (p) (/ (apply distance (line-box-intersect (first p) (second p) box-intersect))
				     (distance (first p) (second p))))
		  (list (list `#(,(box-st-l box-1) ,(box-st-t box-1)) `#(,(box-st-r box-1) ,(box-st-b box-1)))
			  (list `#(,(box-st-l box-1) ,(box-st-b box-1)) `#(,(box-st-r box-1) ,(box-st-t box-1)))
			  (list `#(,(box-st-l box-2) ,(box-st-t box-2)) `#(,(box-st-r box-2) ,(box-st-b box-2)))
			  (list `#(,(box-st-l box-2) ,(box-st-b box-2)) `#(,(box-st-r box-2) ,(box-st-t box-2)))))))))))

;;; Returns a pair of points for the intersection of the line with the passed box
;;; (line-box-intersect '#(-10 20) '#(10 10) (make-box-st 0 0 20 20)) => (#(0 15) #(10 10))
(define (line-box-intersect p1 p2 box)
 (define (calc-y equation x) (+ (* (first equation) x) (second equation)))
 (define (calc-x equation y) (/ (- y (second equation)) (first equation)))
 (define (intersect-of a b u v)
  (define (clip-above x max-x) (if (> x max-x) max-x x))
  (define (clip-below x min-x) (if (< x min-x) min-x x))
  (cond
   ((> a b) (intersect-of b a u v))
   ((> u v) (intersect-of a b v u))
   (else
    `#(,(clip-above (max a u) v) ,(clip-below (min b v) u)))))
 (define (line-gradient p1 p2)
  (if (= (x p1) (x p2))
      infinity
      (/ (- (y p2) (y p1)) (- (x p2) (x p1)))))
 (define (line-equation p1 p2)
  (let ((m (line-gradient p1 p2)))
   (if (equal? m infinity)
       (list m (x p1))
       (list m (- (y p1) (* m (x p1)))))))
 (cond
  ((= (x p1) (x p2)) ;; vertical line
   (if (and (>= (x p1) (box-st-l box)) (<= (x p1) (box-st-r box)))
       (let ((py (intersect-of (y p1) (y p2) (box-st-t box) (box-st-b box)))) 
	  (list `#(,(x p1) ,(x py)) `#(,(x p1) ,(y py))))
       (list p1 p1))) ; line outside of box
  ((= (y p1) (y p2)) ;; horizontal line
   (if (and (>= (y p1) (box-st-b box)) (<= (y p1) (box-st-t box)))
       (let ((px (intersect-of (x p1) (x p2) (box-st-l box) (box-st-r box)))) 
	  (list `#(,(x px) ,(y p1)) `#(,(y px) ,(y p1))))
       (list p1 p1))) ; line outside of box
  ((> (x p1) (x p2)) ; so that p1 is always to the left of p2
   (line-box-intersect p2 p1 box))
  (else ; oblique line, with (x p1) < (x p2)
   (let* ((equation (line-equation p1 p2))
	    (pt `#(,(calc-x equation (box-st-t box)) ,(box-st-t box)))
	    (pb `#(,(calc-x equation (box-st-b box)) ,(box-st-b box)))
	    (pl `#(,(box-st-l box) ,(calc-y equation (box-st-l box))))
	    (pr `#(,(box-st-r box) ,(calc-y equation (box-st-r box))))
	    (px (intersect-of (x p1) (x p2) (box-st-l box) (box-st-r box)))
	    (px (intersect-of (x px) (y px) (x pt) (x pb)))
	    (py (intersect-of (y p1) (y p2) (box-st-t box) (box-st-b box)))
	    (py (intersect-of (x py) (y py) (y pl) (y pr))))
    (if (> (y p1) (y p2))
	  ;; line has a downward slope
	  (list `#(,(x px) ,(y py)) `#(,(y px) ,(x py)))
	  ;; line has an upward slope
	  (list `#(,(x px) ,(x py)) `#(,(y px) ,(y py))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (read-cachable-result cache-file recalculate-fun force-recalculate)
 (if (and (not force-recalculate) (file-exists? cache-file))
     (read-object-from-file cache-file)
     (let ((result (recalculate-fun)))
      (system (format #f "mkdir -p \"$(dirname \"~a\")\"" cache-file))
      (write-object-to-file result cache-file)
      result)))

;;; The file name where we cache results for the passed metric
(define (get-team-score-file video team-1 team-2 metric)
 (format #f "~a/~a-~a-~a-~a.interrater.sc"
	 *box-coder-data-dir* team-1 team-2
	 (darpa-video->string video) (metric-name metric)))

;;; Converts a team-name into their track-type
;;; (team->track-type "PDU") => "voc4"
(define (team->track-type team)
 (if (equal? team "PDU") "voc4" team))

(define (get-video-team-tracks video team)
 (video-smooth-tracked-boxes-available video (team->track-type team)))

(define (track->smooth-track-boxes video track)
 (read-smooth-tracked-boxes video (first track) (second track) (third track)))

;;; Returns a list of all permutations of subset of "lis" which are length "len"
;;; (permutate '(a b c d) 2)
;;;     ==> ((A B) (A C) (A D) (B A) (B C) (B D) (C A) (C B) (C D) (D A) (D B) (D C))
(define (permutate lis len)
 (let ((len (if (> len (length lis)) 0 len)))
  (let loop ((n 0) (res '()))
   (if (equal? n len)
       res
       (loop (+ n 1)
	     (if (equal? n 0)
		 (map list lis)
		 (remove-if-not identity
				(join (map (lambda (e)
					    (map (lambda (n)
						  (if (member e n) '() (cons e n)))
						 res))
					   lis)))))))))


;;; (unique-pairs '(a b c d)) => ((A B) (A C) (A D) (B C) (B D) (C D))
(define (unique-pairs lis)
 (let ((indicies (let ((l (enumerate (length lis))))
		  (all-values
		   (let ((v1 (a-member-of l)))
		    (list v1 (a-member-of (set-difference l (cons v1 (enumerate v1))))))))))
  (map (lambda (pair) (list (list-ref lis (first pair)) (list-ref lis (second pair))))
       indicies)))

;;; Returns a sublist of ever nth element of 'l', with the specified offset
(define (every-other-nth-o l nth offset)
 (map second
      (remove-if-not
       (lambda (e) (first e))
       (map-indexed (lambda (elem i) (list (if (equal? (remainder i nth) offset) #t #f) elem)) l))))

;;; The weighted mean of x, using weights w
(define (weighted-mean w x)
 (if (null? w)
     0
     (/ (foldl + (map * w x) 0)
	  (foldl + w 0))))

;;; Estimates the stddev for the passed list of numbers
(define (weighted-stddev-est w x)
 (if (< (length w) 2)
     0
     (let* ((sum-w (- (foldl + w 0) 1))
		(mean (weighted-mean w x))
		(xi-x (map (lambda (xi) (- xi mean)) x))
		(xx (map * w xi-x xi-x)))
      (sqrt (/ (foldl + xx 0) sum-w)))))

;;; The average of the list
(define (average l)
 (if (null? l)
     0
     (/ (foldl + l 0) (length l))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Scoring

;;; Returns the /average/ box-st-overlap-score between the two tracks,
;;; and the number of frames used to calculate the average. The number
;;; of frames is the first value in the result, and the average is the second
(define (score-tracks track-1 track-2 metric)
 (if (not (= (length track-1) (length track-2)))
     (begin
     ;'(format #t "~%~%~%~%################### Error in video ~a ~%~%~%~%")
;	      (darpa-video->string video))
      (list 0 0))
     (let ((scores (remove-if-not number?
				  (map (metric-fun metric)
				       (map voc4-track->box-st track-1)
				       (map voc4-track->box-st track-2)))))
      (if (> (length scores) 0)
	  (list (length scores) (/ (foldl + scores 0) (length scores)))
	  (list 0 0)))))

;;; Returns the /average/ score-tracks for each pair of tracks.
;;; Both lists must be the same length
;;; The return value is a list, with the first value being the
;;; number of frames used to generate the average score, and the
;;; second being the average score.
(define (score-track-lists  track-1-list track-2-list metric)
 (if (= 0 (length track-1-list))
     (list 0 0)
     (let ((scores (map (lambda (t1 t2) (score-tracks  t1 t2 metric))
				track-1-list track-2-list)))
      (list (foldl + (map first scores) 0)
		(/ (foldl + (map second scores) 0) (length scores))))))

;;; Returns the best possible score (as define by metric, pairing each of the
;;; tracks against each of the other possible tracks. The return value is a list
;;; with two elements where the first gives the total number of frames used in
;;; the scoring, and the second gives the score.
(define (score-track-combinations tracks1 tracks2 metric)
 (if (or (null? tracks1) (null? tracks2))
     '(0 0)
					;(display "hello length of tracks1: ")
					;(display (length tracks1))
					;(display " length of tracks2: ")
					;(display (length tracks2))
					;(newline)
     ;;(dtrace "LT1" (length tracks1))
     ;; (dtrace "LT2" (length tracks2))
     ;;(dtrace "firstll1" (length (first tracks1)))
     ;;(dtrace "firstll2" (length (first tracks2)))
     ;; 	;;		  (dtrace "SCORE=" (length (second tracks1)))
     ;; (dtrace "FIRSTL1" (first tracks1))

     (let* ((tracks
	     (if (not (= (length (first tracks1)) (length (first tracks2))))
		 (begin
		  (format #t "Warning, score-tracks-combinations called on videos with different lengths, ~a and ~a~%"
			  (length (first tracks1)) (length (first tracks2)))
		  (let ((m (min (length (first tracks1)) (length (first tracks2)))))
		   (list (map (lambda (track) (take-if-possible m track)) tracks1)
			 (map (lambda (track) (take-if-possible m track)) tracks2))))
		 (list tracks1 tracks2)))
	    (tracks1 (first tracks))
	    (tracks2 (second tracks)))
      (if (< (length tracks2) (length tracks1))
	  ;; so team1-len always < team2-len
	  (score-track-combinations tracks2 tracks1 metric)
	  (let ((min-len (length tracks1)))
	   (if (or (> min-len *max-permutations-to-try*)
		   (= min-len 0)
		   (> (length tracks2) 10))
	       (list 0 0)
	       (let* ((indicies2 (permutate (enumerate (length tracks2)) min-len))
		      (scores (map
			       (lambda (index-set2)
				(let ((score
				       (score-track-lists tracks1
							  (map (lambda (idx)
								(list-ref tracks2 idx))
							       index-set2)
							  metric)))
				 score))
			       indicies2)))
		(dtrace "scores" scores)
		(if (null? scores)
		    (list 0 0)
		    (choose-highest-score  scores)))))))))

(define (get-human-annotation-tracks video)
 (let* ((directory (generic-directory-pathname video))
       (annotations (dtrace "good annotations"
			    (read-object-from-file (string-append
					    directory
					    "human-track-annotation.sc")))))
   (removeq #f (map (lambda (annotation)
		    (if (track-annotation-good? annotation)
			(list (track-annotation-name annotation)
			      (read-voc4-overgenerated-smooth-tracked-boxes
			       video ;(any-video->string video)
			       (track-annotation-name annotation)
			       (track-annotation-number annotation)))
			#f))
		   annotations))))

(define (get-available-smooth-tracks video)
 (get-available-tracks video
		       video-voc4-smooth-tracked-boxes-available
		       read-voc4-smooth-tracked-boxes))

(define (get-available-annotater-tracks video)
 (get-available-tracks video
		       (lambda (video)
			(video-boxes-available video "voc4_human" "smooth-tracked-box"))
		       (lambda (video model number)
			(read-smooth-tracked-boxes video "voc4_human" model number))))

(define (get-available-tracks video available-f read-f)
 (map (lambda (track)
       (list (second track)
	     (read-f
	      video
	      (second track)
	      (third track))))
      (available-f video)))

(define (compare-video-tracks video1 video2 use-annotations? metric)
 (let* ((tracks1 (if use-annotations?
		     (get-available-annotater-tracks video1)
		     (get-available-smooth-tracks video1)))
	(tracks2 (get-available-smooth-tracks video2))
	(person-tracks1 (remove-if-not person-track? tracks1))
	(person-tracks2 (remove-if-not person-track? tracks2))
	(other-tracks1 (remove-if person-track? tracks1))
	(other-tracks2 (remove-if person-track? tracks2))
	(person-score
	 (score-track-combinations  (map second person-tracks1)
				    (map second person-tracks2)
				    metric))
	(other-score
	 (score-track-combinations  (map second other-tracks1)
				    (map second other-tracks2)
				    metric)))
  (dtrace "Tracks1" (append (map first person-tracks1) (map first other-tracks1)))
  (dtrace "Lengths" (map length (map second (append person-tracks1 other-tracks1))))
  (dtrace "Tracks2" (append (map first person-tracks2) (map first other-tracks2)))
  (dtrace "Lengths" (map length (map second (append person-tracks2 other-tracks2))))
 
  (if (and (equal? 0 (first person-score))
	   (equal? 0 (first other-score)))
      #f
      ;; This is a weighted average, by number of frames used in generating the score
      (list (+ (first person-score) (first other-score))
	    (/ (+ (* (first person-score) (second person-score))
		  (* (first other-score) (second other-score)))
	       (+ (first person-score) (first other-score)))))
  
  (dtrace "person-score" person-score)
  (dtrace "other-score" other-score)
  (newline)
					;(display tracks1)
  (if (and (equal? 0 (first person-score))
	   (equal? 0 (first other-score)))
      #f
      ;; This is a weighted average, by number of frames used in generating the score
      (list (+ (first person-score) (first other-score))
	    (/ (+ (* (first person-score) (second person-score))
		  (* (first other-score) (second other-score)))
	       (+ (first person-score) (first other-score)))))))

(define (pretty-comparison sorta-ground-truth video2 use-annotations?)
 (dtrace "Video-path-name" *video-pathname*)
 (dtrace "Sorta ground truth" sorta-ground-truth)
 (dtrace "Video2" video2)
 (let* ((result (compare-video-tracks sorta-ground-truth
				      video2
				      use-annotations?
				      *intersection-union-metric*))
	(score (if (and (list? result) (> (length result) 1))
			(second result)
			0.0))
	(rounded-score (number->string-of-length-and-precision score 4 2)))
  (format #t "~%Score = ~a~%" rounded-score)))

(define *v1* #f)
(define *v2* #f)
 
(define (test-me)
 (pretty-comparison *v1* *v2* #t))

(define (setup)
 (set! *video-pathname* "/aux/amichaux/tmp/video-datasets/ground-truth")
 (let* ((video-string "Chase1_A1_C1_Act1_4_PARK1_ML_MIDD_DARK_4433d840-c5af-11df-bed3-e80688cb869a")
	(v1 (string->darpa-video video-string))
	(v2 (make-stand-alone-video
	     "/aux/amichaux/tmp/pipeline/C-D1/recognition/Chase1_A1_C1_Act1_4_PARK1_ML_MIDD_DARK_4433d840-c5af-11df-bed3-e80688cb869a1280x720@30.avi")))
  (set! *v1* v1)
  (set! *v2* v2)))

;; (setup)


